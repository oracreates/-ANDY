<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sipp Metaverse Demo</title>
<style>
  body { margin:0; overflow:hidden; font-family: monospace; background:#222;}
  #info { position: absolute; top: 10px; left: 10px; color: white; z-index: 10; }
  #canvasContainer { width: 100vw; height: 100vh; display:block; }
  #inventory { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); display:flex; gap:5px; z-index:10;}
  .block-slot { width: 40px; height: 40px; border: 2px solid white; display:flex; align-items:center; justify-content:center; cursor:pointer;}
  .block-slot.selected { border-color: yellow; }
</style>
</head>
<body>
<div id="info">Use WASD + Mouse to move. Left click = break block, Right click = place block</div>
<div id="inventory"></div>
<div id="canvasContainer"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/js/controls/PointerLockControls.js"></script>
<script>
// --- Setup scene ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 2, 5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('canvasContainer').appendChild(renderer.domElement);

// --- Lighting ---
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5,10,5);
scene.add(light);

// --- Controls ---
const controls = new THREE.PointerLockControls(camera, renderer.domElement);
document.body.addEventListener('click', ()=>{controls.lock()});
const velocity = new THREE.Vector3();
let direction = new THREE.Vector3();
let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false, canJump=false;

document.addEventListener('keydown',(e)=>{
  if(e.code==='KeyW') moveForward=true;
  if(e.code==='KeyS') moveBackward=true;
  if(e.code==='KeyA') moveLeft=true;
  if(e.code==='KeyD') moveRight=true;
  if(e.code==='Space' && canJump){ velocity.y += 5; canJump=false; }
});
document.addEventListener('keyup',(e)=>{
  if(e.code==='KeyW') moveForward=false;
  if(e.code==='KeyS') moveBackward=false;
  if(e.code==='KeyA') moveLeft=false;
  if(e.code==='KeyD') moveRight=false;
});

// --- Ground ---
const blockSize = 1;
const ground = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
const groundMat = new THREE.MeshLambertMaterial({color:0x228B22});
for(let x=-10;x<=10;x++){
  for(let z=-10;z<=10;z++){
    const cube = new THREE.Mesh(ground, groundMat);
    cube.position.set(x*blockSize,0,z*blockSize);
    scene.add(cube);
  }
}

// --- Player Avatar (Sipp Pixel) ---
let walletAddress = prompt("Enter your wallet address to generate Sipp avatar:");
function generatePixelColor(addr){
  let hash=0; for(let i=0;i<addr.length;i++) hash=addr.charCodeAt(i)+(hash<<5)-hash;
  const colors=[0xff0000,0x00ff00,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xffffff,0x888888];
  return colors[Math.abs(hash)%colors.length];
}
const avatarGeo = new THREE.BoxGeometry(0.8,1.6,0.8);
const avatarMat = new THREE.MeshLambertMaterial({color: generatePixelColor(walletAddress)});
const player = new THREE.Mesh(avatarGeo, avatarMat);
player.position.set(0,1,0);
scene.add(player);

// --- Block Placement ---
const blockTypes = [
  {name:"Grass", color:0x00ff00},
  {name:"Stone", color:0x888888},
  {name:"Dirt", color:0x8B4513},
  {name:"Water", color:0x1E90FF},
];
let selectedBlock = 0;

// --- Inventory UI ---
const inventoryDiv = document.getElementById('inventory');
blockTypes.forEach((b,i)=>{
  const slot = document.createElement('div');
  slot.classList.add('block-slot'); if(i===0) slot.classList.add('selected');
  slot.style.backgroundColor = '#' + b.color.toString(16).padStart(6,'0');
  slot.onclick=()=>{selectedBlock=i; document.querySelectorAll('.block-slot').forEach(s=>s.classList.remove('selected')); slot.classList.add('selected');}
  inventoryDiv.appendChild(slot);
});

// --- Raycaster for block interaction ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function breakOrPlaceBlock(place){
  raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
  const intersects = raycaster.intersectObjects(scene.children);
  if(intersects.length>0){
    const intersect = intersects[0];
    if(place){
      const cubeGeo = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
      const cubeMat = new THREE.MeshLambertMaterial({color:blockTypes[selectedBlock].color});
      const cube = new THREE.Mesh(cubeGeo, cubeMat);
      cube.position.copy(intersect.point).add(intersect.face.normal.multiplyScalar(0.5)).floor();
      cube.position.x=Math.floor(cube.position.x)+0.5;
      cube.position.y=Math.floor(cube.position.y)+0.5;
      cube.position.z=Math.floor(cube.position.z)+0.5;
      scene.add(cube);
    } else {
      if(intersect.object!==player) scene.remove(intersect.object);
    }
  }
}
document.addEventListener('mousedown', (e)=>{
  if(e.button===0) breakOrPlaceBlock(false);
  if(e.button===2) breakOrPlaceBlock(true);
});
document.addEventListener('contextmenu', e=>e.preventDefault());

// --- Game loop ---
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  velocity.x -= velocity.x * 10.0 * delta;
  velocity.z -= velocity.z * 10.0 * delta;
  velocity.y -= 9.8 * 5 * delta;

  direction.z = Number(moveForward)-Number(moveBackward);
  direction.x = Number(moveRight)-Number(moveLeft);
  direction.normalize();

  if(moveForward||moveBackward) velocity.z -= direction.z*10*delta;
  if(moveLeft||moveRight) velocity.x -= direction.x*10*delta;

  controls.moveRight(-velocity.x*delta);
  controls.moveForward(-velocity.z*delta);
  controls.getObject().position.y += velocity.y*delta;

  if(controls.getObject().position.y<1){ velocity.y=0; controls.getObject().position.y=1; canJump=true;}
  player.position.copy(controls.getObject().position);
  camera.position.copy(controls.getObject().position).add(new THREE.Vector3(0,0,0));
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);});
</script>
</body>
</html>